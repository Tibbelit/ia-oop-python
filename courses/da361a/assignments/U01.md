---
layout: instructions
code: da361a
title: Uppgift 1
---

# Uppgift 1

Betyg: G

## Uppgift

I denna uppgift arbetar ni i grupper om tre, såsom de delats upp av Johan och Anton. Grupperna hittar ni på Canvas. Uppgiften består av två deluppgifter, vilka båda måste lösas för att ni ska bli godkända.

### Del 1 - OOA och OOD

I den här deluppgiften ska ni göra klass- och sekvensdiagram. Hur dessa ska ritas beskrivs längre ner i texten. Systemet ni ska jobba med är ett meddelandesystem, i vilket personer kan skicka enkla meddelanden mellan varandra via en server. Delsystemet Server är givet och kan bortses från helt. Det är således delsystemet Klient som ni ska designa. Klienten utgör programvaran som en användare använder i meddelandesystemet.

Designen av systemet ska följa tanken om boundary-, control- och entity-klasser:

 * Boundary-klasser har att göra med ingen eller en mycket liten del av logiken i systemet. De känner endast till control-klasser och eventuellt även andra boundary-klasser.
 * Control-klasserna ansvarar för den övergripande logiken i systemet och behöver känna till både boundary- och entity-klasser. Control-klasserna behöver dock inte känna till alla boundary- och entitity-klasser.
 * Entity-klasser representerar data i systemet och ansvarar för beräkningar och transformationer av denna data. Entity-klasser känner endast till andra entity-klasser och eventuellt control-klasser.

#### Funktioner som ska implementeras i systemet

Klientapplikationen består av ett textgränssnitt och av funktionalitet för att kommunicera med en server. Applikationen har en meny med fyra val:

 * Koppla upp/ner
 * Visa en lista över uppkopplade användare
 * Skriv ett nytt meddelande
 * Visa befintliga meddelanden i en lista. Dessa visas på följande vis:

> Meddelande från **Förnamn Efternamn** (**datum**):
> **Här hamnar meddelandetexten.**

En klient ska kunna ansluta sig till och koppla ner sig från servern, visa, skicka och ta emot meddelanden, samt visa en lista över uppkopplade användare.

#### Om klienten

Det finns tre givna klasser som ni utgår från. Utöver dessa får ni lägga till vilka klasser ni vill. Dessa tre klasser är:

##### Message

Klassen *Message* utgör superklass till samtliga meddelanden som skickas mellan klient och server. Varje typ av meddelande som ni identifierar ska ärva från denna klass. Följande publika metoder är givna:

 * *getSender()*, som returnerar ett objekt av klassen *User* (se nedan).
 * *setSender(User)*, som sätter avsändaren av ett meddelande.
 * *getReceptionTime()*, som returnerar en sträng. Denna sträng innehåller information om datum och tid rörande när meddelandet togs emot av servern.
 * *getTimeOfDelivery()*, som returnerar en sträng. Denna sträng innehåller information om datum och tid rörande när meddelandet levererades till användaren.
 * *getContents()*, som returnerar ett objekt. Detta objekt innehåller meddelandets faktiska innehåll, och varierar beroende på vilken typ av meddelande som skickas.

Observera att inte alla meddelanden behöver ha en mottagare, eftersom en del meddelanden bara går mellan användaren och servern (som exempelvis upp- och nedkoppling). Ett meddelande mellan användare ska dock kunna skickas till en eller flera mottagare.

##### User

Klassen *User* representerar en användare. Följande publika metoder är givna:

 * *getFirstName()*, som returnerar en sträng.
 * *setFirstName(string)*, som sätter förnamnet.
 * *getLastName()*, som returnerar en sträng.
 * *setLastName(string)*, som sätter efternamnet.

##### Connection

Klassen *Connection* ansvarar för kommunikationen med servern. Ni behöver inte bry er om hur meddelandena faktiskt skickas till och tas emot från servern. Följande publika metoder är givna:

 * *connect()*, som skickar ett meddelandeobjekt till servern och berättar att klienten kopplar upp.
 * *disconnect()*, som skickar ett meddelande till servern och berättar att klienten kopplar ner.
 * *send(Message)*, som skickar ett godtyckligt meddelande till servern.

Utöver dessa finns även en privat metod:

 * *update(Message)*, som uppdaterar relevanta boundary-klasser med information när nya meddelanden skickas från servern. Den här metoden är abstrakt, och således även klassen, så ni behöver skapa en klass som ärver av *Connection* för att implementera ovanstående funktionalitet.

#### Er uppgift

##### Klassdiagram

Skapa ett klassdiagram över klientapplikationen. Glöm inte att införa era egna klasser utifrån de behov ni identifierar. Diagrammet ska ha hög detaljrikedom med associationstyper, multipliciteter, viktiga attribut och metoder.

##### Sekvensdiagram

Rita sekvensdiagram för följande scenarier:
 * Användaren kopplar upp klienten mot servern.
 * Användaren kopplar ner klienten.
 * Användaren skriver och skickar ett meddelande.
 * Servern levererar ett meddelande till klienten.
 * Servern levererar ett meddelande med uppkopplade användare.

Tänk på att hålla klassdiagram och sekvensdiagram konsistenta med varandra!

### Del 2 - Från kod till UML

HÄR SKRIVER ANTON IN SIN UPPGIFT

## Inlämning

_Inlämningen görs i grupp. Detta innebär att enbart en i gruppen lämnar in lösningen. Vid enventuella problem i gruppen, prata med Johan eller Anton._

Inlämning sker i form av en `zip` fil innehållande upggiftens båda delar. Det är upp till er att strukturera innehållet så länge ni är noggranna med namngivning av filer och/eller mappar. **Deadline** finner ni på Canvas.
